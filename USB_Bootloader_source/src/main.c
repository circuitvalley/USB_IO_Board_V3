/*******************************************************************************
     
    File:   main.c
    Author:  Gaurav Singh
    website: www.circuitvalley.com 
    Created on October 28, 2017
    
    This file is part of Circuitvalley USB HID Bootloader.

    Circuitvalley USB HID Bootloader is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Circuitvalley USB HID Bootloader is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Circuitvalley USB HID Bootloader.  If not, see <http://www.gnu.org/licenses/>.
*******************************************************************************/

/*********************************************************************
IMPORTANT NOTES: This code is intended to be used with both the F and LF 
versions of the following devices:

PIC16F1459
PIC16F1455
PIC16F1454

Verify that the configuration bits are set correctly for the intended
target application, and that they match the application firmware project(s)
that you intend to program with this bootloader.

This project needs to be built with the XC8 compiler optimizations
fully enabled in PRO mode, in order to fit within the program memory
space reserved for this bootloader firmware.  If you attempt to build this
project in some other mode (free or standard), you will likely receive one or more
error messages such as "can't find xxx words ... for psect ...", as the code size will
be too large to fit within the 0x000-0xAFF memory region that has been reserved
for this bootloader firmware project.


----------------------Bootloader Entry------------------------------------------
Entry into this bootloader firmware is done by an I/O pin check at power up/after
any device reset.

The I/O pin that will be checked is the "sw2" pin, as defined in the 
HardwareProfile.h file.

----------------Making a bootloadable .hex application project file-------------
 The hardware reset vector address for the PIC16F145x devices is 0x000, while
 the interrupt handler vector is 0x004.  These addresses are occupied by this
 bootloader firmware (which uses the 0x000-0x8FF region, and also reserves 0x900-0x903).  The application
 firmware images that are intended to be programmed by this bootloader must
 therefore be written to avoid using any part of the 0x000-0x903 region.

 This can be done by setting the XC8 linker properties in the application firmware
 project to reserve the 0x000-0x903 region, and to "offset" the linked in code
 (generated by the application firmware project) by 0x904.

 To reserve the 0x000-0x903 region, the ROM ranges, needs to be filled with "default, -0-903"
 This setting can be found at:

 Build configuration settings --> XC8 global options --> XC8 linker --> Option categories (dropdown): Memory model --> ROM ranges: default,-0-903

 To "offset" the generated code by 0x904, the Codeoffset setting must be set to 0x904 under:

 Build configuration settings --> XC8 global options --> XC8 linker --> Option categories (dropdown): Additional options --> Codeoffset: 0x904

 The above two linker setting changes should all that should be necessary to
 make the output .hex file programmable by this bootloader firmware.

--------------------------------------------------------------------------------
Anytime that an application implements flash self erase/write capability, 
special care should be taken to make sure that the microcontroller is operated 
within all datasheet ratings, especially those associated with voltage versus 
frequency.

Operating the device at too high of a frequency (for a given voltage, ex: by
operating at 48MHz at 2.1V, while the device datasheet indicates some higher
value such as 2.35V+ is required) can cause unexpected code operation.  This
could potentially allow inadvertent execution of bootloader or other self
erase/write routines, causing corruption of the flash memory of the application.

To avoid this, all applications that implement self erase/write capability 
should make sure to prevent execution during overclocked/undervolted conditions.

For this reason, enabling and using the microcontroller hardware Brown-out-Reset 
feature is particularly recommended for applications using a bootloader.  If 
BOR is not used, or the trip threshold is too low for the intended application 
frequency, it is suggested to add extra code in the application to detect low 
voltage conditions, and to intentionally clock switch to a lower frequency 
(or put the device to sleep) during the low voltage condition.  Hardware
modules such as the ADC, comparators, or the HLVD (high/low voltage detect)
can often be used for this purpose.


--------------------------------------------------------------------------------
This bootloader supports reprogramming of the microcontroller configuration bits,
however, it is strongly recommended never to do so, unless absolutely necessary.
Reprogramming the config bits is potentially risky, since it requires that the
new configuration bits be 100% compatible with USB operation (ex: oscillator
settings, etc.).  If a .hex file with incorrect config bits is programmed
into this device, it can render the bootloader inoperable.  Additionally,
unexpected power failure or device detachment during the reprogramming of the
config bits could result in unknown values getting stored in the config bits,
which could "brick" the application.

Normally, the application firmware project and this bootloader project should
be configured to use/set the exact same configuration bit values.  Only one set
of configuration bits actually exists in the microcontroller, and these values
must be shared between the bootloader and application firmware.
*******************************************************************************/



#include "usb.h"
#include "HardwareProfile.h"
#include "BootPIC16F145x.h"

//Configuration bit settings.  Make sure these match with the firmware project
//that will be programmed by this bootloader.
#define USE_INTERNAL_OSC 1
#if defined (USE_INTERNAL_OSC)  //Definition in the hardware profile
    __CONFIG(FOSC_INTOSC & WDTE_OFF & PWRTE_OFF & MCLRE_OFF & CP_OFF & BOREN_ON & CLKOUTEN_OFF & IESO_OFF & FCMEN_OFF);
    __CONFIG(WRT_OFF & CPUDIV_NOCLKDIV & USBLSCLK_48MHz & PLLMULT_3x & PLLEN_ENABLED & STVREN_ON &  BORV_LO & LPBOR_OFF & LVP_OFF);
#else
    __CONFIG(FOSC_HS & WDTE_OFF & PWRTE_ON & MCLRE_OFF & CP_OFF & BOREN_ON & CLKOUTEN_OFF & IESO_OFF & FCMEN_OFF);
    __CONFIG(WRT_OFF & CPUDIV_NOCLKDIV & USBLSCLK_48MHz & PLLMULT_4x & PLLEN_ENABLED & STVREN_ON &  BORV_LO & LPBOR_OFF & LVP_OFF);
#endif



//------------------------------------------------------------------------------
//Private prototypes
//------------------------------------------------------------------------------
void main(void);
void BootMain(void);
void LowVoltageCheck(void);
void InitializeSystem(void);
void BlinkUSBStatus(void);


//------------------------------------------------------------------------------
//Special constant definitions
//------------------------------------------------------------------------------
//Absolute entry point into the bootloader firmware (so application firmware
//projects can jump into bootloader mode at runtime).
#define BOOTLOADER_ABSOLUTE_ENTRY_ADDRESS       0x001C  //Execute "movlp 0x00 and goto 0x001C" inline assembly instructions, if you want to enter the bootloader mode from the application via software
//To make a runtime jump from application run mode into bootloader mode, execute
//a jump to the BOOTLOADER_ABSOLUTE_ENTRY_ADDRESS.  This can be done like follows
//(assuming 0x001C entry point):
//#asm
//    movlp 0x00
//    goto 0x001C
//#endasm


//------------------------------------------------------------------------------
//Special constants in program memory
//------------------------------------------------------------------------------
//Special flash signature word at special address.  Normally used to prove an erase/program/verify
//operation was successful, but we place it here so that the user can take the output
//hex file from this project, and add it as a loadable to an application project,
//and then program both the bootloader and application firmware images simultaneously.
const unsigned char FlashSignatureWord @APP_SIGNATURE_ADDRESS = APP_SIGNATURE_VALUE;


//------------------------------------------------------------------------------
//RAM Variables
//------------------------------------------------------------------------------
uint16_t uint_delay_counter;
uint8_t DummyVar;


//------------------------------------------------------------------------------
//Interrupt vector remapping code
//------------------------------------------------------------------------------
//This project doesn't actually use interrupts, but interrupts may be used in
//the application firmware that will be programmed by this bootloader.  Therefore,
//we put a "goto" at the hardware interrupt vector address, to jump to the
//application firmware's interrupt handler routine.
void interrupt ISRCode()
{
    //Jump to the remapped interrupt vector, which is at program memory address 0x904
    #asm
        movlp APP_SPACE_START_HI_BYTE
        goto APP_SPACE_REMAP_INT_VECTOR_LO_11BITS
    #endasm
}




/******************************************************************************
 * Function:        void main(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This is the first code that executes during boot up of
 *                  the microcontroller.  This code checks to see if execution
 *                  should stay in the "bootloader" mode, or if it should jump
 *                  into the "application" (non-bootloder) execution mode.
 *                  No other unrelated code should be added to this function.
 *
 * Note:            
 *****************************************************************************/
void main(void)
{
    unsigned int i;

    //Note: If you disable MLCR (so it gets used as RA3 general purpose input)
    //and then use RA3 as the bootloader entry check I/O pin, it is recommended
    //to have some bootup delay prior to checking the RA3 pin to see if entry
    //into the bootloader or application should occur.  This is useful if there
    //is capacitance on RA3 and the pull up is weak enought that the RA3 rises
    //slower than VDD.  Without a bootup delay here, this could allow the
    //microcontroller to execute and check the I/O pin when it has not yet reached
    //the proper value.  This is also possible immediately after exiting ICSP programming
    //mode, as it may take some time for the programmer to tri-state the MCLR/RA3
    //pin and for the pull up resistor to overcome any capacitance on the pin.
    for(i = 0; i < 1000; i++);    //Make sure this delay is long enough for the sw2 pin can
                                //fully settle to the correct value based on the PCB circuit,
                                //prior to doing the I/O pin bootloader entry check.

    
    //Perform startup check of I/O pin to see if we should stay in bootloader
    //mode (ex: because the user is pressing the pushbutton on the board)
    #if defined(ENABLE_IO_PIN_CHECK_BOOTLOADER_ENTRY)   //See usb_config.h
        mInitSwitch2();
        if(sw2 == 0)
        {
            //Statup check of I/O pin detected low state.  Stay in bootloader mode.
            BootMain();
        }
    #endif
    
    //If we get to here, that means the user is not trying to enter bootloader
    //mode by I/O pin.  However, we still need to stay in bootloader mode
    //if no application firmware image is present at all, or if the last
    //erase/program/verify sequence was interrupted, causing the flash memory
    //signature word location to contain the wrong value.

    //Check to verify the flash memory has the correct signature word
    //value, indicating that the application space firmware image is intact
    //and was successfully erased/programmed/verified/signed when last
    //reprogrammed.
    PMCON1bits.CFGS = 0;
    PMADR = APP_SIGNATURE_ADDRESS;
    PMCON1bits.RD = 1;  //Initiate flash memory read operation
    Nop();              //2 Nops() required, see datasheet
    Nop();
    if((PMDATL == APP_SIGNATURE_VALUE) && (PMDATH == RETLW_OPCODE_MSB))
    {
        //The signature word was valid.  Now make one more check to ensure
        //0x900 has been programmed with a non blank value (ex: != 0x3FFF),
        //indicating that an application firmware image has been programmed
        //into the device.
        PMADR = APP_SPACE_RESET_VECTOR;
        PMCON1bits.RD = 1;  //Initiate flash memory read operation
        Nop();              //2 Nops() required, see datasheet
        Nop();
        //Check for completely blank value or not.  If the location is not
        //blank, this means we have an application firmware image programmed
        //in the device, and we should jump to it now.
        if(PMDAT != BLANK_FLASH_WORD_VALUE)
        {
            //Jump out of this bootloader firmware and into the main
            //application firmware entry point at APP_SPACE_START_ADDRESS.
            #asm
                movlp APP_SPACE_START_HI_BYTE
                goto APP_SPACE_START_LOWER_11BITS
            #endasm
        }
    }//if((PMDATL == APP_SIGNATURE_VALUE) && (PMDATH == 0x34))
    
	//Else we stay in bootloader mode
	BootMain();
}

/******************************************************************************
 * Function:        void BootMain(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This is the main function for this bootloader mode firmware.
 *                  if execution gets to this function, it is assumed that we
 *                  want to stay in bootloader mode for now.
 *
 * Note:            If adding code to this function, make sure to add it only
 *                  after the C initializer like code at the top of this function.
 *                  Additionally, code written in this project should not assume
 *                  any variables or registers have been initialized by the C
 *                  compiler (since they may not have been, if the user jumped
 *                  from the application run mode into bootloader mode directly).
 *****************************************************************************/
void __at(BOOTLOADER_ABSOLUTE_ENTRY_ADDRESS) BootMain(void)
{
    //Initialize everything
    //Make sure interrupts are disabled for this code (could still be on,
    //if the application firmware jumped into the bootloader via software methods)
    INTCON = 0x00;  
    //Clear the stack pointer, in case the user application jumped into 
    //bootloader mode with excessive junk on the call stack
    STKPTR = 0x00;  

    //End of the important parts of the C initializer.  This bootloader firmware does not use
    //any C initialized user variables (idata memory sections).  Therefore, the above is all
    //the initialization that is normally required.

    //Make sure that if the WDT is enabled, that it is set to long enough timeout
    //period that it doesn't timeout during flash erase/write sequences (which take
    //quite awhile to complete and halt CPU execution during the operation).
    WDTCONbits.WDTPS = 0b01100; //~2 second timeout


    //Call other initialization code and (re)enable the USB module
    InitializeSystem();     //Some USB, I/O pins, and other initialization
    
    //Execute main loop
    while(1)
    {
        ClrWdt();
        
        //Need to call USBDeviceTasks() periodically.  This function takes care of
        //processing non-USB application related USB packets (ex: "Chapter 9" 
        //packets associated with USB enumeration)
        USBDeviceTasks();

        BlinkUSBStatus();   //When enabled, blinks LEDs on the board, based on USB bus state
        
        LowVoltageCheck();  //Regularly monitor voltage to make sure it is sufficient
                            //for safe operation at full frequency and for erase/write
                            //operations.       
        
        ProcessIO();        //This is where all the actual bootloader related data transfer/self programming takes
                            //place see ProcessIO() function in the BootPIC[xxxx].c file.
    }//end while    
}//end of BootMain()






/******************************************************************************
 * Function:        static void InitializeSystem(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        InitializeSystem is a centralize initialization routine.
 *                  All required USB initialization routines are called from
 *                  here.
 *
 *                  User application initialization routine should also be
 *                  called from here.                  
 *
 * Note:            None
 *****************************************************************************/
void InitializeSystem(void)
{
   //Configure oscillator settings to be compatible with USB operation
    #if defined(USE_INTERNAL_OSC)
        OSCCON = 0xFC;   //3x PLL enabled from 16MHz HFINTOSC
        ACTCON = 0x90;   //Enable active clock tuning from USB
        while(OSCSTATbits.PLLRDY == 0); //Wait for PLL ready/locked
    #endif

    #if defined(YOUR_CUSTOM_BOARD)
        #advisory "Add oscillator initialization settings here."
        //Add any necessary oscillator initialization code here.  The settings
        //selected here must be compatible with USB full speed operation.
    #endif
    
	
    //The USB specifications require that USB peripheral devices must never source
    //current onto the +5V VBUS pin.  Additionally, USB peripherals should not source
    //current on D+ or D- when the host/hub is not actively powering the VBUS line.
    //When designing a self powered (as opposed to bus powered) USB peripheral
    //device, the firmware should make sure not to turn on the USB module and D+
    //or D- pull up resistor unless Vbus is actively powered.  Therefore, the
    //firmware needs some means to detect when VBUS is being powered by the host.
    //A 5V tolerant I/O pin can be connected to VBUS (through a resistor), and
    //can be used to detect when VBUS is high (host actively powering), or low
    //(host is shut down or otherwise not supplying power - note weak pull down, ex: 100k,
    //should also be placed on the PCB on VBUS to ensure low/non-floating reading).
    //The USB firmware can then periodically poll this I/O pin to know when it is okay
    //to turn on the USB module/D+/D- pull up resistor.  When designing a purely bus powered
    //peripheral device, it is not possible to source current on D+ or D- when the
    //host is not actively providing power on VBUS. Therefore, implementing this
    //bus sense feature is optional.  This firmware can be made to use this bus
    //sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the
    //usb_config.h file.
    #if defined(USE_USB_BUS_SENSE_IO)
        tris_usb_bus_sense = INPUT_PIN; // See HardwareProfile.h
    #endif

    //If the host PC sends a GetStatus (device) request, the firmware must respond
    //and let the host know if the USB peripheral device is currently bus powered
    //or self powered.  See chapter 9 in the official USB specifications for details
    //regarding this request.  If the peripheral device is capable of being both
    //self and bus powered, and it can consume >100mA from VBUS, it should not
    //return a hard coded value for this request.
    //Instead, firmware should check if it is currently self or bus powered, and
    //respond accordingly.  If the hardware has been configured like demonstrated
    //on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the
    //currently selected power source.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"
    //has been defined in usb_config.h, and that an appropriate I/O pin has been mapped
    //to it in HardwareProfile.h.  This feature is optionional and is not required
    //to be implemented on bus powered only or self/bus powered device that never
    //take more than 100mA from VBUS.
    #if defined(USE_SELF_POWER_SENSE_IO)
        tris_self_power = INPUT_PIN;
    #endif

    UserInit();                 //Initialize bootloader application variables (see Bootxxxx.c file)
    #if defined(ENABLE_USB_LED_BLINK_STATUS)
        mLED1 = 0;      //LED off initially
        mLED1Tris = 0;  //Configure pin as output
    #endif

	//Initialize USB module only after oscillator and other settings are compatible with USB operation
    USBDeviceInit();	//Initializes USB module SFRs and firmware
    					//variables to known states.
}//end InitializeSystem


    


/******************************************************************************
 * Function:        void BlinkUSBStatus(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        BlinkUSBStatus turns on and off LEDs corresponding to
 *                  the USB device state.
 *
 * Note:            mLED macros can be found in HardwareProfile.h
 *                  usb_device_state is declared in usbmmap.c and is modified
 *                  in usb_device.c, usbctrltrf.c, and usb9.c
 *****************************************************************************/
void BlinkUSBStatus(void)
{
    #ifdef ENABLE_USB_LED_BLINK_STATUS
        static unsigned int led_count = 0;

        led_count--;
        if(led_count == 0)
        {
            led_count = 0x4E00;     //Value determines blink interval
            if(USBGetDeviceState() < CONFIGURED_STATE)
            {
                mLED1 = 1;          //Turn on the LED continuously
            }
            else
            {
                mLED1 = !mLED1;     //Toggle the LED state
            }
        }
    #endif //#ifdef ENABLE_USB_LED_BLINK_STATUS
}//end BlinkUSBStatus



//Check to make sure the VDD is sufficient for safe bootloader operation.
//If the voltage is insufficient, code should be added to the below
//function that clock switches to a low frequency internal oscillator and
//puts the device to sleep, so as to avoid accidental operation under
//"overclocked" (for a given voltage) conditions.  If BOR is enabled and is
//set at a high enough level to trip before reaching a level insufficient for
//maximum frequency operation, it may not be necessary to add additional checks
//and the below warning can simply be commented out.
void LowVoltageCheck(void)
{
    #advisory "Recommended to implement code here to check VDD.  Voltage detection can be done using ADC, HVLD, comparators, or other means."
}    



// ******************************************************************************************************
// ************** USB Callback Functions ****************************************************************
// ******************************************************************************************************
// The USB firmware stack will call the callback functions USBCBxxx() in response to certain USB related
// events.  For example, if the host PC is powering down, it will stop sending out Start of Frame (SOF)
// packets to your device.  In response to this, all USB devices are supposed to decrease their power
// consumption from the USB Vbus to <2.5mA* each.  The USB module detects this condition (which according
// to the USB specifications is 3+ms of no bus activity/SOF packets) and then calls the USBCBSuspend()
// function.  You should modify these callback functions to take appropriate actions for each of these
// conditions.  For example, in the USBCBSuspend(), you may wish to add code that will decrease power
// consumption from Vbus to <2.5mA (such as by clock switching, turning off LEDs, putting the
// microcontroller to sleep, etc.).  Then, in the USBCBWakeFromSuspend() function, you may then wish to
// add code that undoes the power saving things done in the USBCBSuspend() function.
//
// Note *: The "usb_20.pdf" specs indicate 500uA or 2.5mA, depending upon device classification. However,
// the USB-IF has officially issued an ECN (engineering change notice) changing this to 2.5mA for all
// devices.  Make sure to re-download the latest specifications to get all of the newest ECNs.

/******************************************************************************
 * Function:        void USBCBWakeFromSuspend(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        The host may put USB peripheral devices in low power
 *                  suspend mode (by "sending" 3+ms of idle).  Once in suspend
 *                  mode, the host may wake the device back up by sending non-
 *                  idle state signalling.
 *
 *                  This call back is invoked when a wakeup from USB suspend
 *                  is detected.
 *
 * Note:            Before returning from this function, make sure that the
 *                  oscillator settings are fully compatible with USB module
 *                  operation.
 *                  If using the two-speed startup feature, wakeup and execution
 *                  will occur before the main oscillator + PLL has had a chance
 *                  to start.  Device will run from INTOSC (no PLL).  However, the
 *                  USB module cannot be clocked and receive correct USB data when
 *                  it is not clocked with the correct frequency clock source.
 *                  Therefore, when using two-speed startup, should execute software
 *                  delay to prevent any other code from executing until the main
 *                  oscillator is ready.
 *                  The host will allow at least 10ms for USB "resume recovery", during
 *                  which it will not try to communicate with the device.
 *****************************************************************************/
void USBCBWakeFromSuspend(void)
{
    //This code delays ~5ms @ 8MHz to execute (using C18 3.21 with full 
    //optimizations enabled), but takes much less time at 48MHz.  This delay
    //is to make sure the PLL is enabled and locked, in case two speed startup
    //was enabled
    DelayRoutine(0x300);  //Device will switch clocks (if using two-speed startup) while executing this delay function
    
    //Primary oscillator and PLL should be running by now.

    //Do not return from this function until the oscillator is correctly configured and
    //running in a USB compatible mode/frequency.


    //Additional code for re-enabling I/O pins and increasing power draw from VBUS
    //may be placed here (up to the maximum of 100mA [when unconfigured] or the
    //amount specified in the configuration descriptor (when configured).
}



/******************************************************************************
 * Function:        void USBCBSuspend(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        Call back that is invoked when a USB suspend is detected
 *
 * Note:            None
 *****************************************************************************/
void USBCBSuspend(void)
{
    //Configure I/O pins for lowest power.  This will be application specific.
    #ifdef ENABLE_USB_LED_BLINK_STATUS
        mLED1 = 0;  //Turn off LED
    #endif

    Sleep();                // Go to sleep, wake up when a USB activity event occurs
    //If using the WDT, should go back to sleep if awoke by WDT instead of USBIF
    while((USBIF_FLAG == 0))      //If using the WDT, should go back to sleep if awoke by WDT instead of USBIF
    {
        Sleep();                //Entry into sleep clears WDT count, much like executing ClrWdt() instruction
    }

    //After the USB suspend event ends, you should re-configure your I/O pins
    //for normal operation mode (which is allowed to consume more current).
    //However, it is recommended to put this code in the USBCBWakeFromSuspend()
    //function instead of here (so that this function will work with either
    //sleeping or clock switching to a lower frequency).
}


/*******************************************************************
 * Function:        void USBCBInitEP(uint8_t ConfigurationIndex)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This function is called when the device becomes
 *                  initialized, which occurs after the host sends a
 *                  SET_CONFIGURATION request.  This
 *                  callback function should initialize the endpoints
 *                  for the device's usage according to the current
 *                  configuration.
 *
 * Note:            If the host ever "unconfigures" the device, it will
 *                  set the configuration to '0'.  In this case, this
 *                  callback gets called with ConfigurationIndex == 0, where
 *                  the firmware should disable all non-EP0 endpoints (until
 *                  the next non-zero SET_CONFIGURATION request is received,
 *                  which will cause this callback to execute again).
 *******************************************************************/
void USBCBInitEP(uint8_t ConfigurationIndex)
{
    //Check what configuration "index" the host has requested us to select.
    //Configuration index 0 is special and represents that the device should be
    //un-configured.  However, when the host sets the configuration (with index
    //matching the valid/implemented configuration from the configuration descriptor),
    //the firmware should enable the application endpoints associated with that
    //configuration, and (re)initialize all application state variables associated
    //with the USB application endpoints operation.
    if(ConfigurationIndex == 1)     //This application only implements one configuration, with index == 1.
    {
        //The host sent us a non-zero set configuration index.  In this
        //case we should prepare the application endpoints to be ready
        //to use, and to (re-)initialize any application variables associated
        //with the endpoints.
        HIDInitEP();

        //(Re-)Initialize the application variables associated with the USB interface
        UserInit();                     // See BootPIC[xxxx].c.  Initializes the bootloader firmware state machine variables.
    }
    //else the host set the configuration back to 0 (indicating unconfigured), or
    //to some higher (non-implemented value).  In either case, we don't need to
    //do anything specifically, unless the application requires some kind of
    //"safe shutdown" code to execute after the host has deconfigured the device.

}



/*******************************************************************
 * Function:        void USBCBCheckOtherReq(void)
 *
 * PreCondition:    None
 *
 * Input:           None
 *
 * Output:          None
 *
 * Side Effects:    None
 *
 * Overview:        This function is called when the USB stack receives a
 *                  new control transfer SETUP packet from the host.  The
 *                  USB stack handles normal USB "Chapter 9" requests internally,
 *                  but some control transfer requests are class specific.  In
 *                  order to handle these class specific requests, you must call
 *                  the class handler's firmware control transfer handler function.
 *                  If implementing a composite device with multiple classes
 *                  implemented, call each of the handlers in the below callback.
 *
 * Note:            None
 *******************************************************************/
void USBCBCheckOtherReq(void)
{
    USBCheckHIDRequest();
}


//Compiler mode and version check.  This code needs to fit within the [0x000-0xFFF] program
//memory region that is reserved for use by the bootloader.  However, if this
//code is built in XC8 Standard or Free mode (instead of PRO),
//the code may be too large to fit within the region, and a variety of linker
//error messages (ex: "can't find space") will result.  Unfortunately these
//linker error messages can be cryptic to a user, so instead we add a deliberate
//#error to make a more human friendly error appear, in the event the wrong
//compiler mode is attempted to use to build this code.  If you get this error
//message, please upgrade to the PRO compiler, and then use the mode
//(ex: build configuration --> XC8 compiler --> Option Categories: Optimizations --> Operation Mode: PRO)

#ifdef __XC8__
    #if _HTC_EDITION_ < 2   //Check if PRO, Standard, or Free mode
    #error "This bootloader project must be built in PRO mode to fit within the reserved region.  Double click this message for more details."
    #endif
#endif

/** EOF main.c ***************************************************************/
